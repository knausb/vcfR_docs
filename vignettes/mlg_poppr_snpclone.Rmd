---
title: "Analysis of multilocus genotypes and lineages in poppr using a snpclone object"
author: "Brian J. Knaus"
date: "March 2, 2016"
output: html_document
---


Documentation already exists for the Analysis of Multilocus Genotypes and Lineages in poppr using the genind and genclone objects.
This can be viewed in the poppr package's vignettes.

```{r, eval=FALSE}
RShowDoc('mlg', package='poppr')
```


Data resulting from high throughput sequencing projects require greater performance than these objects were originally designed for.
This document is intended to provide a similar analytical path using objects of class genlight and snpclone which have been designed specifically for high throughput applications.

## Multilocus genotypes

A multilocus genotype (mlg) is a unique combination of alleles across two or more loci.
In populations of clonal or partially clonal organisms the observation of an mlg in a genotyping project may indicate that the same individual was sampled muliple times (e.g., different hyphae of a mycelium).
This typically violates assumptions of population genetics analyses.
One way to address this is to 'clone correct' the data by selecting one of each mlg for analysis.


## Creation of a snpclone object

The creation of snpclone objects is covered elsewhere.
Here we use the pinfsc50 dataset read in as a VCF file and converted to an object of class snpclone.


```{r, echo=TRUE, message=FALSE, warning=FALSE}
# Load libraries
library(vcfR)
library(pinfsc50)
library(poppr)

# Determine file locations
vcf_file <- system.file("extdata", "pinf_sc50.vcf.gz",
                        package = "pinfsc50")

# Read data into memory
vcf <- read.vcfR(vcf_file, verbose = FALSE)

# Convert to genlight object
my.genlight <- vcfR2genlight(vcf)

# Convert to snpclone object
my.snpclone <- poppr::as.snpclone(my.genlight)
```


We now have an object of class snpclone and can query its contents.

```{r}
my.snpclone
```


## High throughput MLG


High throughput genotyping results in thousands, tens of thousands, hundreds of thousand or more variants.
This means that even within clones we expect to observe some level of variation.
Some fraction of this observed variation may be real somatic mutation.
A larger fraction is more likely to result from genotyping error.
Two forms of mlg appear relevant to high throughput sequencing assays: a distance threshold ("contracted") or a custom specification defined by the user ("custom").


The mlg slot of the snpclone object contains information on mlg specification for the samples.
Information can be queried from this slot using the `mll()` method.


```{r}
mll(my.snpclone)
```


The default behaviour appear to be that each sample is assigned to a unique mlg.
Below we'll learn how to set this slot to something that is (hopefully) of biological relevance.


## Filtered ("contracted") mlg


```{r}
mlg.filter(my.snpclone, threshold=0.1, distance=bitwise.dist)
```



```{r, fig.align='center'}
set.seed(1)
g1 <- poppr.msn(gid=my.snpclone, distmat=bitwise.dist(my.snpclone), threshold = 0.1, include.ties = TRUE, 
                vertex.label.color = "firebrick", vertex.label.font = 2)
```




```{r, fig.align='center'}
mlg.table(my.snpclone)
```



## Tie breakers (algorithms)

Underlying mlg.filter are three algorithms that decide what genotypes go together (Kamvar, Brooks, and GrÃ¼nwald 2015):

* nearest neighbor
* farthest neighbor (default)
* average neighbor (UPGMA)


```{r, fig.align='center'}
pinf_filtered <- filter_stats(my.snpclone, distance = bitwise.dist, plot = TRUE)
```




## Section


```{r}
my.snpclone

hist(bitwise.dist(my.snpclone), col=3)

pthresh <- mlg.filter(my.snpclone)

cutoff_predictor(pthresh)


missingno(my.snpclone)

filter_stats(my.snpclone, plot=TRUE)


mlg.filter(my.snpclone, threshold=0.05)
mlg.filter(my.snpclone) <- 0.05

mlg.id(my.snpclone)



```





