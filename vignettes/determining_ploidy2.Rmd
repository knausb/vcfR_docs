---
title: "Determining ploidy"
author: "Brian J. Knaus"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Subset to one chromosome}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---



```{r global_options, include=FALSE}
knitr::opts_chunk$set(fig.align = 'center')
knitr::opts_chunk$set(fig.width = 8)
knitr::opts_chunk$set(fig.height = 8)
```



For some organisms ploidy information is unclear.
This is important because while current variant callers can accomodate different ploidies they cannot infer ploidy.
The user needs to specify the ploidy as an option.
Here I explore a method to infer ploidy from VCF data.


## Input data


Data import is performed similar to other examples.


```{r}
# Load libraries
library(vcfR)
library(pinfsc50)

# Determine file locations
vcf_file <- system.file("extdata", "pinf_sc50.vcf.gz",
                        package = "pinfsc50")

# Read data into memory
vcf <- read.vcfR(vcf_file, verbose = FALSE)
vcf
```


## Allele balance


In high throughput sequencing we sequence each allele multiple times.
For heterozygotes it is assumed that we sequence each allele an equal number of times.
For example, if we sequence a diploid heterozygote at 30X we would expect to sequence each allele 15 times.
Some variation around this expectation may be due to sequencing error.
If we sequence a triploid heterozygote with a genotype of A/A/T at 30X we would expect to sequence A 20 times and T 10 times.
Because we can not determine which A was sequenced we can only report the sum of all sequences even though we expect to sequence both A alleles 10 times.
For a triploid heterozygote with a genotype of A/C/T sequenced at 30X would expect to sequence A 10 times, C 10 times and T 10 times.


```{r}
knitr::kable(vcf@gt[c(1:2,11,30),1:4])
```


The 'AD' field in our VCF data includes the depth at which each allele was sequenced.
We can extract this information with the function `extract.gt()`.


```{r}
ad <- extract.gt(vcf, element = 'AD')
```


```{r}
knitr::kable(ad[c(1:2,11,30),1:4])
```


The function `extract.gt()` isolates the 'AD' data from the colon delimited string in the VCF data.
We expect integer counts for the number of sequences observed.
However, because this data is comma delimited we need another step before we have integers.
We use the function `masplit()` to extract the first and second allele.
At that point we have integers so we can use math to create allele frequencies from the counts.


```{r}
allele1 <- masplit(ad, record = 1)
allele2 <- masplit(ad, record = 2)

ad1 <- allele1 / (allele1 + allele2)
ad2 <- allele2 / (allele1 + allele2)
```


One we have our allele frequencies we can plot them in a histogram.


```{r}
hist(ad2[,"P17777us22"], breaks = seq(0,1,by=0.02), col = "#808080", xaxt="n")
hist(ad1[,"P17777us22"], breaks = seq(0,1,by=0.02), col = "#C0C0C0", add = TRUE)
axis(side=1, at=c(0,0.25,0.333,0.5,0.666,0.75,1), labels=c(0,"1/4","1/3","1/2","1/3","3/4",1))
```




The most common class of variant is the homozygote.
This overwhelms the plot.
We can remove these so we can focus on the heterozygotes.


```{r}
gt <- extract.gt(vcf, element = 'GT')
hets <- is_het(gt)

is.na( ad[ !hets ] ) <- TRUE

allele1 <- masplit(ad, record = 1)
allele2 <- masplit(ad, record = 2)

ad1 <- allele1 / (allele1 + allele2)
ad2 <- allele2 / (allele1 + allele2)

hist(ad2[,"P17777us22"], breaks = seq(0,1,by=0.02), col = "#808080", xaxt="n")
hist(ad1[,"P17777us22"], breaks = seq(0,1,by=0.02), col = "#C0C0C0", add = TRUE)
axis(side=1, at=c(0,0.25,0.333,0.5,0.666,0.75,1), labels=c(0,"1/4","1/3","1/2","1/3","3/4",1))
```


This allows us to focus on the heterozygous variants and we observe a peak at 0.5 consistent with our expectation.
However, the frequencies range almost completely from 0 to one.
This suggests some improvement could be made.


## Allele Depth


To get an idea on how to improve our plots we can take a closer look at allele depth.


```{r}
ad <- extract.gt(vcf, element = 'AD')
#ad[1:3,1:4]

allele1 <- masplit(ad, record = 1)
allele2 <- masplit(ad, record = 2)

# Subset to a vector for manipulation.
tmp <- allele1[,"P17777us22"]
#sum(tmp == 0, na.rm = TRUE)
#tmp <- tmp[tmp > 0]
tmp <- tmp[tmp <= 100]

hist(tmp, breaks=seq(0,100,by=1), col="#808080", main = "P17777us22")

sums <- apply(allele1, MARGIN=2, quantile, probs=c(0.15, 0.95), na.rm=TRUE)
sums[,"P17777us22"]
abline(v=sums[,"P17777us22"], col=2, lwd=2)

```


Here we have presented the number of times the most abundant allele was sequenced as a histogram.
We see two classes of calls resulting in peaks at just below 40 and just below 60.
These peaks correspond to heterozygotes and homozygotes respectively.
There are a substantial number of variants with exceptionally high coverage, here we've limited the presentation to just variants below 100.
There is also a substantial peak near zero representing variants sequenced at low coverage.
Filtering this data by imposing some sort of threshold may improve our other analyses.
Here we've used the 15% and 95% quantiles.


```{r, eval=FALSE, echo=FALSE}
#gq <- extract.gt(vcf, element = 'GQ', as.numeric = TRUE)
#plot(allele1[!hets[,"P17777us22"],"P17777us22"] + allele1[!hets[,"P17777us22"],"P17777us22"], gq[!hets[,"P17777us22"],"P17777us22"], pch = 20, col = "#8B451366")
#plot(allele1[!hets[,"P17777us22"],"P17777us22"], gq[!hets[,"P17777us22"],"P17777us22"], pch = 20, col = "#8B451366")
#abline(v=0:5*10, col="#808080")
```


We can see how this treatment looks on the second most abundant allele as well.


```{r}
tmp <- allele2[,"P17777us22"]
tmp <- tmp[tmp>0]
tmp <- tmp[tmp<=100]

hist(tmp, breaks=seq(1,100,by=1), col="#808080", main="P17777us22")

sums[,"P17777us22"]
abline(v=sums[,"P17777us22"], col=2, lwd=2)
```


We can use this information to filter our data.
First we'll look at the raw data.


```{r}
#vcf <- extract.indels(vcf)
#gq <- extract.gt(vcf, element = 'GQ', as.numeric = TRUE)
#vcf@gt[,-1][ gq < 99 ] <- NA

ad <- extract.gt(vcf, element = 'AD')
allele1 <- masplit(ad, record = 1)
allele2 <- masplit(ad, record = 2)
boxplot(allele1, las=3)
```


Now we can use our quantiles to censor variants outside of our desired range by setting them to NA.


```{r}
sums <- apply(allele1, MARGIN=2, quantile, probs=c(0.15, 0.95), na.rm=TRUE)
# Allele 1
dp2 <- sweep(allele1, MARGIN=2, FUN = "-", sums[1,])
#allele1[dp2 < 0] <- NA
vcf@gt[,-1][ dp2 < 0 & !is.na(vcf@gt[,-1]) ] <- NA
dp2 <- sweep(allele1, MARGIN=2, FUN = "-", sums[2,])
#allele1[dp2 > 0] <- NA
vcf@gt[,-1][dp2 > 0] <- NA
# Allele 2
dp2 <- sweep(allele2, MARGIN=2, FUN = "-", sums[1,])
vcf@gt[,-1][ dp2 < 0 & !is.na(vcf@gt[,-1]) ] <- NA
dp2 <- sweep(allele2, MARGIN=2, FUN = "-", sums[2,])
vcf@gt[,-1][dp2 > 0] <- NA

# Hard filter
#dp[dp < 4] <- NA
#
vcf@gt[,-1][allele1 < 8] <- NA
#
vcf@gt[,-1][allele2 < 8] <- NA

```


Now we can check out work with another set of box and whisker plots.


```{r}
ad <- extract.gt(vcf, element = 'AD')
allele1 <- masplit(ad, record = 1)
allele2 <- masplit(ad, record = 2)
boxplot(allele1, las=3)
#hist(allele1[,"P17777us22"], ylim=c(0,2000), breaks = seq(0,100,by=5) )
```


Now we can see if our histogram of allele balance has been cleaned up.


```{r}
gt <- extract.gt(vcf, element = 'GT')
hets <- is_het(gt)
is.na( ad[ !hets ] ) <- TRUE

allele1 <- masplit(ad, record = 1)
allele2 <- masplit(ad, record = 2)

ad1 <- allele1 / (allele1 + allele2)
ad2 <- allele2 / (allele1 + allele2)

hist(ad2[,"P17777us22"], breaks = seq(0,1,by=0.02), col = "#808080", xaxt="n", main="P17777us22")
hist(ad1[,"P17777us22"], breaks = seq(0,1,by=0.02), col = "#C0C0C0", add = TRUE)
axis(side=1, at=c(0,0.25,0.333,0.5,0.666,0.75,1), labels=c(0,"1/4","1/3","1/2","1/3","3/4",1))
```


We see that the shoulders that were present in the previous plot are almost entirely removed.
This appears to be a dramatic improvement.



## A panel of samples


```{r, fig.height=3}

barplot(sort(sums[1,], decreasing = TRUE), las=3)

barplot(sort(apply(ad1, MARGIN=2, function(x){sum(!is.na(x))}), decreasing = TRUE), las=3)
#plot(sums[1,], apply(ad1, MARGIN=2, function(x){sum(!is.na(x))}))
```


```{r}

knitr::kable(sums[,1:9])
knitr::kable(sums[,10:18])


#pdf('pinfsc50_hists.pdf', width=8, height=8)

par(mfrow = c(6,3))
par(mar=c(2,2,2,0))

for(i in 1:18){
  hist(ad2[,i], breaks = seq(0,1,by=0.02), col = "#808080", xaxt="n", main="", xlab="", ylab="")
  hist(ad1[,i], breaks = seq(0,1,by=0.02), col = "#C0C0C0", add = TRUE)
  axis(side=1, at=c(0,0.25,0.333,0.5,0.666,0.75,1), labels=c(0,"1/4","1/3","1/2","1/3","3/4",1))
  title( main = colnames(ad1)[i])
  abline(h=seq(0,40,by=5) * 10, col="#80808088")
  abline(h=seq(0,10,by=2), col="#80808088", lty=2)
}

#dev.off()

par(mfrow = c(1,1))
par(mar=c(5,4,4,2))
```



