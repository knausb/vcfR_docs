---
title: "Determining ploidy"
author: "Brian J. Knaus"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Subset to one chromosome}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---



```{r global_options, include=FALSE}
knitr::opts_chunk$set(fig.align = 'center')
```



For some organisms ploidy information is unclear.
This is important because while current variant callers can accomodate different ploidies they cannot infer ploidy.
The user needs to specify the ploidy as an option.
Here I explore a method to infer ploidy from VCF data.


## Input data


Data import is performed similar to other examples.


```{r}
# Load libraries
library(vcfR)
library(pinfsc50)

# Determine file locations
vcf_file <- system.file("extdata", "pinf_sc50.vcf.gz",
                        package = "pinfsc50")

# Read data into memory
vcf <- read.vcfR(vcf_file, verbose = FALSE)
vcf
```



```{r}
ad <- extract.gt(vcf, element = 'AD')
ad[1:3,1:4]

allele1 <- masplit(ad, record = 1)
allele2 <- masplit(ad, record = 2)


#par(mfrow=c(2,1))
adp <- allele1[,"P17777us22"]
adp <- adp[adp>=10]
adp <- adp[adp<=100]
hist(adp, breaks=seq(0, max(adp)+1, by=1))
axis(side=1,at=1:4*10)


adp <- allele2[,"P17777us22"]
adp <- adp[adp>0]
#adp <- adp[adp>=10]
adp <- adp[adp<=100]
hist(adp, breaks=seq(0, max(adp), by=1))
#par(mfrow=c(1,1))


library(reshape2)
library(ggplot2)


dpf <- melt(allele1, varnames=c('Index', 'Sample'), value.name = 'Depth', na.rm=TRUE)
dpf <- dpf[ dpf$Depth > 0,]
p <- ggplot(dpf, aes(x=Sample, y=Depth)) + geom_violin(fill="#C0C0C0", adjust=1.0,
                                                       scale = "count", trim=TRUE)
p <- p + theme_bw()
p <- p + theme(axis.title.x = element_blank(), 
               axis.text.x = element_text(angle = 60, hjust = 1))
p <- p + scale_y_continuous(trans=scales::log2_trans(), 
                            breaks=c(1, 10, 100, 800),
                            minor_breaks=c(1:10, 2:10*10, 2:8*100))
p <- p + theme( panel.grid.major.y=element_line(color = "#A9A9A9", size=0.6) )
p <- p + theme( panel.grid.minor.y=element_line(color = "#C0C0C0", size=0.2) )
p


dpf <- melt(allele2, varnames=c('Index', 'Sample'), value.name = 'Depth', na.rm=TRUE)
dpf <- dpf[ dpf$Depth > 0,]
p <- ggplot(dpf, aes(x=Sample, y=Depth)) + geom_violin(fill="#C0C0C0", adjust=1.0,
                                                       scale = "count", trim=TRUE)
p <- p + theme_bw()
p <- p + theme(axis.title.x = element_blank(), 
               axis.text.x = element_text(angle = 60, hjust = 1))
p <- p + scale_y_continuous(trans=scales::log2_trans(), 
                            breaks=c(1, 10, 100, 800),
                            minor_breaks=c(1:10, 2:10*10, 2:8*100))
p <- p + theme( panel.grid.major.y=element_line(color = "#A9A9A9", size=0.6) )
p <- p + theme( panel.grid.minor.y=element_line(color = "#C0C0C0", size=0.2) )
p



ad1 <- allele1 / (allele1 + allele2)
ad2 <- allele2 / (allele1 + allele2)


hist(ad2[,"P17777us22"], breaks = seq(0,1,by=0.02), col = "#808080", xaxt="n")
hist(ad1[,"P17777us22"], breaks = seq(0,1,by=0.02), col = "#C0C0C0", add = TRUE)
axis(side=1, at=c(0,0.25,0.333,0.5,0.666,0.75,1), labels=c(0,"1/4","1/3","1/2","1/3","3/4",1))


gt <- extract.gt(vcf, element = 'GT')

hets <- is_het(gt)

is.na(ad[ !hets ]) <- TRUE

allele1 <- masplit(ad, record = 1)
allele2 <- masplit(ad, record = 2)

ad1 <- allele1 / (allele1 + allele2)
ad2 <- allele2 / (allele1 + allele2)


hist(ad2[,"P17777us22"], breaks = seq(0,1,by=0.02), col = "#808080", xaxt="n")
hist(ad1[,"P17777us22"], breaks = seq(0,1,by=0.02), col = "#C0C0C0", add = TRUE)
axis(side=1, at=c(0,0.25,0.333,0.5,0.666,0.75,1), labels=c(0,"1/4","1/3","1/2","1/3","3/4",1))

hist(ad2[,"blue13"], breaks = seq(0,1,by=0.02), col = "#808080", xaxt="n")
hist(ad1[,"blue13"], breaks = seq(0,1,by=0.02), col = "#C0C0C0", add = TRUE)
axis(side=1, at=c(0,0.25,0.333,0.5,0.666,0.75,1), labels=c(0,"1/4","1/3","1/2","1/3","3/4",1))


allele2[1:3,1:4]

is.na(ad[allele2 < 20]) <- TRUE

allele1 <- masplit(ad, record = 1)
allele2 <- masplit(ad, record = 2)

ad1 <- allele1 / (allele1 + allele2)
ad2 <- allele2 / (allele1 + allele2)


hist(ad2[,"P17777us22"], breaks = seq(0,1,by=0.02), col = "#808080", xaxt="n")
hist(ad1[,"P17777us22"], breaks = seq(0,1,by=0.02), col = "#C0C0C0", add = TRUE)
axis(side=1, at=c(0,0.25,0.333,0.5,0.666,0.75,1), labels=c(0,"1/4","1/3","1/2","1/3","3/4",1))

hist(ad2[,"DDR7602"], breaks = seq(0,1,by=0.02), col = "#808080", xaxt="n")
hist(ad1[,"DDR7602"], breaks = seq(0,1,by=0.02), col = "#C0C0C0", add = TRUE)
axis(side=1, at=c(0,0.25,0.333,0.5,0.666,0.75,1), labels=c(0,"1/4","1/3","1/2","1/3","3/4",1))

hist(ad2[,"P13626"], breaks = seq(0,1,by=0.02), col = "#808080", xaxt="n")
hist(ad1[,"P13626"], breaks = seq(0,1,by=0.02), col = "#C0C0C0", add = TRUE)
axis(side=1, at=c(0,0.25,0.333,0.5,0.666,0.75,1), labels=c(0,"1/4","1/3","1/2","1/3","3/4",1))

hist(ad2[,"blue13"], breaks = seq(0,1,by=0.02), col = "#808080", xaxt="n")
hist(ad1[,"blue13"], breaks = seq(0,1,by=0.02), col = "#C0C0C0", add = TRUE)
axis(side=1, at=c(0,0.25,0.333,0.5,0.666,0.75,1), labels=c(0,"1/4","1/3","1/2","1/3","3/4",1))


```




## Filtering

The data appear 'noisy' and only high coverage samples produce obvious distributions.
Here I make a few attempts at filtering the data to improve this.


First we can subset to the heterozygous positions.

```{r}
gt <- extract.gt(vcf)
hets <- is.het(gt)
is.na(vcf@gt[,-1][!hets]) <- TRUE
```


Build a confidence interval for coverage.


```{r}
dp <- extract.gt(vcf, element = "DP", as.numeric = TRUE)
#sums <- apply(dp, MARGIN=2, quantile, probs=c(0.05, 0.95), na.rm=TRUE)
#sums <- apply(dp, MARGIN=2, quantile, probs=c(0.1, 0.9), na.rm=TRUE)
sums <- apply(dp, MARGIN=2, quantile, probs=c(0.2, 0.8), na.rm=TRUE)

knitr::kable(t(sums))

dp2 <- sweep(dp, MARGIN=2, FUN = "-", sums[1,])
dp[dp2 < 0] <- NA
dp2 <- sweep(dp, MARGIN=2, FUN = "-", sums[2,])
dp[dp2 > 0] <- NA
#dp[dp < 4] <- NA
is.na( vcf@gt[,-1][ is.na(dp) ] ) <- TRUE
```


Set a hard minimum threshold.


```{r}
dp <- extract.gt(vcf, element = "DP", as.numeric = TRUE)
dp[ is.na(dp) ] <- 0
is.na(vcf@gt[,-1][ dp < 10 ]) <- TRUE
```



## Querying the ALT column for multiple alleles


The presence of more than two alleles at a locus may be evidence of higher levels of ploidy.
Note that more than two alleles can occur in a population of diploids.
It is the instance when an individual has more than two alleles that suggests higher ploidy levels.
When more than two alleles are present the ALT column will include a comma delimited list of alleles that are alternate to the (haploid) reference.
We can parse this data with the `strsplit()` function.


```{r}
n.alt <- unlist(lapply(strsplit(vcf@fix[,'ALT'], ","), length))
table(n.alt)
```


We see that the majority of variants have a single alternate allele.
There is a reasonable population of variants with two alternate alleles.
As well as a rare occurrence of three or four alleles.


## Extract allele depths


The VCF data we are using was created using the GATK's haplotype caller.
This variant caller produces allele depth, or the number of times each allele was sequenced, in the file.
This is coded in the FORMAT column as 'AD.'


```{r}
vcf@gt[1:3,1:2]
```


The allele depth is part of the comma delimited string that forms the gt portion of the file.
This can be parsed by using the function `extract.gt()`.
This results in a comma delimited string that still needs to be parsed before we have numerics.
This can be done with the funciton `AD_frequency()`.


```{r}
dp <- extract.gt(vcf, element = "DP", as.numeric = TRUE)
ad <- extract.gt(vcf, element = "AD")
ad[1:3,1:4]
ad1 <- AD_frequency(ad, allele = 1, sum_type = 1)
ad1[1:3, 1:4]
ad2 <- AD_frequency(ad, allele = 2, sum_type = 1)
ad3 <- AD_frequency(ad, allele = 3, sum_type = 1)
ad4 <- AD_frequency(ad, allele = 4, sum_type = 1)
ad5 <- AD_frequency(ad, allele = 5, sum_type = 1)
```


The function `AD_frequency()` sorts the alleles by their abundance and the parameter `allele` is used to report which allele to calculate a frequency for.
For example, setting `allele = 1` will report the frequency of the most abundant allele.
Similarly, setting `allele = 2` will report the frequency of the second most abundant allele.


## The fifth allele

If we have a variant that has five alleles but no individual has five alleles then the frequency of the fifth allele should be zero.


```{r}
samps <- c(1:3,15)
gt <- extract.gt(vcf)
gt[n.alt == 4, samps]
ad5[n.alt == 4,samps]
sum( ad5[n.alt == 4,] )
```


This should hold for the fourth and third alleles as well.


```{r}
sum( ad4[n.alt == 4,] )
sum( ad3[n.alt == 4,] )
```


We see that some of these samples appear to have a third allele.


```{r}
hist(ad3[n.alt == 4,], col=8)
```


These appear to be rare alleles that occur at less than one percent.
It may be best to consider this to be genotyping error.


## The fourth allele


We can repeat this exercise for variants with four alleles as well.


```{r}
sum( ad4[n.alt == 3,], na.rm =TRUE )

#ad4[n.alt == 3,9]

ad4[n.alt == 3,17]
ad[n.alt == 3,17]
ad[n.alt == 3,17][7]

table( ad4[,17][ ad4[,17] > 0.01 ] )

```



The sample blue13 appears to have one variant with a fourth allele frequency of 0.22.
The counts per allele are fairly convincing that this locus is tetraploid.
But its one variant out of 22,031.
We'll see if we can find any other evidence.



## The third allele




```{r}
sum( ad3[n.alt == 2,], na.rm =TRUE )

head( ad3[n.alt == 2,] )


i <- 1
hist(ad3[,i][ad3[,i] >= 0.1], col=8, breaks=seq(0,0.5, by=0.02), main=colnames(ad3)[i])
```


```{r, fig.align='center', fig.width=8, fig.height=12}
#par(mfrow=c(3,6))
par(mfrow=c(6,3))

for(i in 1:ncol(ad3)){
  hist(ad3[,i][ad3[,i] > 0.0], col=8, breaks=seq(0,0.5, by=0.02), main=colnames(ad3)[i])
  abline(v=c(0.25, 0.33), col=2)
}


par(mfrow=c(1,1))

```



## The second allele



```{r}
sum( ad2[n.alt == 1,], na.rm =TRUE )

head( ad2[n.alt == 1,] )


i <- 1
hist(ad2[,i][ad2[,i] >= 0.0], col=8, breaks=seq(0,0.5, by=0.02), main=colnames(ad2)[i])

```



```{r, fig.align='center', fig.width=8, fig.height=12}
#par(mfrow=c(3,6))
#
par(mfrow=c(6,3))

for(i in 1:ncol(ad2)){
  hist(ad2[,i][ad2[,i] > 0.0], col=8, breaks=seq(0,0.5, by=0.02), main=colnames(ad2)[i]
#       , ylim=c(0,400)
       )
  abline(v=c(0.25, 0.33), col=2)
}


par(mfrow=c(1,1))

```
